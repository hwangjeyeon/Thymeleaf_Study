리터럴:
타임리프는 다음과 같은 리터럴이 있다
문자: 'hello'
숫자: 10
불린: true , false
null: null

타임리프에서 문자 리터럴은 항상 ''로 감싸야 한다
<span th:text="'hello'">
-> 귀찮아 -> <span th:text="hello">사실 공백없이 어진다면 생략해도 가능하다

하지만 중간에 공백이 있는 경우는 꼭 감싸야한다
<span th:text="'hello world'">

리터럴 대체를 사용하면 편리하게 사용할 수 있다
<span th:text="|Name= ${data}|">

연산
타임리프 연산은 자바와 크게 다르지 않다
단 HTML안에서 사용하기 때문에 HTML 엔티티를 사용하는 부분만 주의하면 된다

산술 연산 -> 기본과 동일
비교 연산 -> HTML 엔티티 사용 가능
조건식 -> 기본과 동일
Elvis 연산자 -> 조건식을 편하게 한 것 a?:b -> a가 true면 a 출력하고 아니면 b 출력
No-Operation -> _을 사용해서 타임리프가 실행되지 않는 것처럼 동작한다 -> _인 부분이 실행되어야 하면 타임리프를 작동하지 않는다
-> 따라서 본문에 있는 부분이 출력된다

속성값 설정
th:* 속성을 지정하면 타임리프는 기존 속성으로 th:*에서 지정한 속성으로 대체한다
<input type="text" name="Yang" th:name="Hwang" /> -> 타임리프에서 렌더링하면 name은 Yang이 아니라 Hwang으로 대체된다

속성 추가:
th:attrappend: 속성 값의 뒤에 값을 추가한다
th:attrprepend: 속성 값의 앞에 값을 추가한다
th:classappend: class 속성에 자연스럽게 추가한다

checked 처리
HTML에서는 checked="false"로 지정해도 checked 속성이 있기 때문에 checked 처리가 된다
-> th:checked는 값이 false이면 checked 속성 자체를 제거한다

반복
타임리프에서의 반복은 th:each를 사용한다
또한 반복에서 사용할 수 있는 여러 상태값도 지원한다

<tr th:each="user : ${users}"> 
-> 반복할때마다 ${users}에서 값을 하나씩 꺼내서 user에 담아서 태그를 반복실행한다
th:each는 List뿐만 아니라 배열, Iterable, Enumeration을 구현한 모든 객체를 반복에 사용할 수 있다
Map도 사용할 수 있는데 이 경우 변수에 담기는 값은 Map.Entry이다.

반복 상태 유지
<tr th:each="user, userStat : ${users}"> 
-> 이것을 통해 반복의 상태를 확인할 수 있다

반복 상태 유지 기능
index : 0부터 시작하는 값
count : 1부터 시작하는 값
size : 전체 사이즈
even , odd : 홀수, 짝수 여부( boolean )
first , last :처음, 마지막 여부( boolean )
current : 현재 객체

조건문
타임리프의 조건문은 if, unless, switch가 있다
unless는 if의 반대라고 생각하면 된다
if와 unless는 해당 조건이 맞지 않으면 태그 자체를 렌더링하지 않는다
switch는 case를 이용해서 사용하는데 *는 기본값이다

주석:
1. 표준 html 주석
<!--
-->

=> 타임리프가 렌더링하지 않고 그대로 주석처리로 남겨둔다

2. 타임리프 파서 주석
<!--/*
*/-->

=> 렌더링할 때 주석부분을 제거한다

3. 타임리프 프로토타입 주석
<!--/*/
/*/-->

=> 웹 브라우저가 렌더링하지 않으나
타임리프 렌더링을 거치면 정상 렌더링이 된다
즉 html 파일을 그대로 열면 주석처리가 되지만, 타임리프를 렌더링 한 경우에만 보인다

th:block은 html 태그가 아닌 타임리프의 유일한 자체 태그로서
렌더링될 때 th:block이 들어간 부분이 제거된다


자바스크립트 인라인: 
타임리프는 자바스크립트에서 타임리프를 편리하게 사용할 수 있는 자바스크립트 인라인 기능을 제공한다
<script th:inline="javascript">

자바스크립트 인라인 사용 유무 차이점:
텍스트 렌더링 -> 인라인을 사용하면 문자 타입인 경우 ""를 자동으로 포함해준다 또한 문제가 될 수 있는 문자가 포함되어 있으면 이스케이프 처리도 해준다
인라인을 사용하지 않으면 변수명으로 잘못 인식되어 사용되므로 오류가 발생할 수 있따

자바스크립트 내츄럴 템플릿
타임리프는 html 파일을 직접 열어도 동작하는 내추렬 템플릿 기능을 제공한다
인라인 사용 전에는 네츄럴 템플릿 기능이 동작하지 않고 렌더링 내용도 주석처리 되어버리고 순수하게 해석된다
인라인 사용 후에는 원하는 값이 정확하게 적용된다

객체
타임리프의 자바스크립트 인라인 기능을 사용하면 객체를 JSON으로 자동으로 변환해준다

자바스크립트 인라인은 each도 지원한다
[# th:each="user : ${users}"]
[# th:each="user, stat : ${users}"]

템플릿 조각
배경: 웹 페이지를 개발할 때 생기는 공통 영역을 일일이 다 수정하는 것은 매우 비효율적이다 
이런 문제를 해결하기 위해 공통 부분을 템플릿 조각 기능을 통해 해결할 수 있다

th:fragment가 있는 태그는 다른 곳에 포함되는 코드 조각이다

th:insert나 th:replace로 가져오고 템플릿에 있는 th:fragment="copy"을 가져와서 사용한다

부분포함 insert는 현재 태그 내부에 추가하고
부분포함 replace는 현재 태를 대체하며
~{}를 사용 하지 않고 부분 포함 단순 표현식을 사용하여 생략할 수 있다

파라미터 사용를 사용하여 동적으로 조각을 렌더링할 수 있다


템플릿 레이아웃
일부 코드 조각을 가져오는 방식도 있지만 코드 조각을 레이아웃에 넘겨서 사용하는 방법도 있다

common_header(~{::title},~{::link} 이 부분을 잘 봐야한다
::title은 공통으로 사용할 소스 페이지의 title 태그들을 전달하고
::link는 추가할 현재 페이지의 link 태그들을 전달한다

공통부분과 추가 부분이 잘 나뉘어져서 출력되는 것을 확인할 수 있다

-> 해당 내용을 head 부분 뿐만 아니라 html영역까지 확장해서 사용할 수 있다





